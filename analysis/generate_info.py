import pefile
import hashlib
import os
import magic
import pefile
import time
import datetime

filename = "1.14.0-x64.exe" # replace with your file name

pe = pefile.PE(filename)

# File name
filename = os.path.basename(filename)
print("File name:", filename)

# OS
if pe.FILE_HEADER.Machine == 0x14c: # Intel 386
    if pe.OPTIONAL_HEADER.Magic == 0x10b: # PE32
        print("OS: Windows 95/98/ME")
    elif pe.OPTIONAL_HEADER.Magic == 0x20b: # PE32+
        print("OS: Windows NT/2000/XP/Vista/7/8/10")
elif pe.FILE_HEADER.Machine == 0x8664: # AMD64
    if pe.OPTIONAL_HEADER.Magic == 0x10b: # PE32
        print("OS: Windows NT/2000/XP/Vista/7/8/10")
    elif pe.OPTIONAL_HEADER.Magic == 0x20b: # PE32+
        print("OS: Windows 7/8/10")

# MIME type
print("MIME type: application/octet-stream")

# File info
print("File info:")
print("\tFile size:", pe.FILE_HEADER.SizeOfOptionalHeader)
print("\tTimestamp:", pe.FILE_HEADER.TimeDateStamp)

# Hashes
with open(filename, 'rb') as f:
    content = f.read()
    md5 = hashlib.md5(content).hexdigest()
    sha1 = hashlib.sha1(content).hexdigest()
    sha256 = hashlib.sha256(content).hexdigest()

print("MD5:", md5)
print("SHA1:", sha1)
print("SHA256:", sha256)

with open(filename, "rb") as f:
    file_data = f.read()

# Get the TRiD information
magic_cl = magic.Magic(mime=True)
mime_type = magic_cl.from_buffer(file_data)
print("MIME type:", mime_type)

magic_cl = magic.Magic()
trid_info = magic_cl.from_buffer(file_data)
print("TRiD information:", trid_info)

try:
    pe = pefile.PE(filename)

    if hasattr(pe, 'FileInfo') and hasattr(pe.FileInfo[0], 'StringTable'):
        string_table = pe.FileInfo[0].StringTable[0]
        print("Product name:", string_table.get("ProductName"))
        print("Product version:", string_table.get("ProductVersion"))
        print("File version:", string_table.get("FileVersion"))
        print("Company name:", string_table.get("CompanyName"))
        print("File description:", string_table.get("FileDescription"))
        print("Legal copyright:", string_table.get("LegalCopyright"))

    # Get the file properties for non-PE files
except pefile.PEFormatError:
    pass

pe = pefile.PE(filename)

print("File type:", "PE")
print("Object file type:", pe.OPTIONAL_HEADER.Subsystem)
print("File OS:", "Win32")
print("File flags:", hex(pe.FILE_HEADER.Characteristics))
print("File flags mask:", hex(pe.FILE_HEADER.Characteristics))
print("Subsystem:", pe.OPTIONAL_HEADER.Subsystem)
print("Subsystem version:", pe.OPTIONAL_HEADER.MajorSubsystemVersion, ".", pe.OPTIONAL_HEADER.MinorSubsystemVersion)
print("Image version:", pe.OPTIONAL_HEADER.MajorImageVersion, ".", pe.OPTIONAL_HEADER.MinorImageVersion)
print("OS version:", pe.OPTIONAL_HEADER.MajorOperatingSystemVersion, ".", pe.OPTIONAL_HEADER.MinorOperatingSystemVersion)
print("Entry point:", hex(pe.OPTIONAL_HEADER.AddressOfEntryPoint))
print("Uninitialized data size:", pe.OPTIONAL_HEADER.SizeOfUninitializedData)
print("Initialized data size:", pe.OPTIONAL_HEADER.SizeOfInitializedData)
print("Code size:", pe.OPTIONAL_HEADER.SizeOfCode)
print("Linker version:", pe.OPTIONAL_HEADER.MajorLinkerVersion, ".", pe.OPTIONAL_HEADER.MinorLinkerVersion)
print("PE type:", "PE32" if pe.FILE_HEADER.Machine == 0x014c else "PE32+" if pe.FILE_HEADER.Machine == 0x8664 else "Unknown")
print("Time stamp:", pe.FILE_HEADER.TimeDateStamp)
print("Machine type:", "x86" if pe.FILE_HEADER.Machine == 0x014c else "x64" if pe.FILE_HEADER.Machine == 0x8664 else "Unknown")


# Load the binary file using pefile
pe = pefile.PE(filename)

# Get the architecture information
# Get the architecture information
architecture = pe.FILE_HEADER.Machine

# Get the subsystem information
subsystem = pe.OPTIONAL_HEADER.Subsystem

# Get the compilation date information
timestamp = pe.FILE_HEADER.TimeDateStamp
date = datetime.datetime.fromtimestamp(timestamp)
compilation_date = date.strftime("%Y-%m-%d %H:%M:%S")

# Print the extracted information
print("Architecture:", hex(architecture))
print("Subsystem:", subsystem)
print("Compilation Date:", compilation_date)

# Print the DOS header values
import subprocess

# Execute the malicious PE file
subprocess.run(["1.14.0-x64.exe"])

# Generate the PAC file
subprocess.run(["python", "generate_pac_file.py"])


dos_header = pe.DOS_HEADER
print("Magic number:", hex(dos_header.e_magic))
print("Bytes on last page of file:", dos_header.e_cblp)
print("Pages in file:", dos_header.e_cp)
print("Relocations:", dos_header.e_crlc)
print("Size of header:", dos_header.e_cparhdr)
print("Min extra paragraphs:", dos_header.e_minalloc)
print("Max extra paragraphs:", dos_header.e_maxalloc)
print("Initial SS value:", hex(dos_header.e_ss))
print("Initial SP value:", hex(dos_header.e_sp))
print("Checksum:", dos_header.e_csum)
print("Initial IP value:", hex(dos_header.e_ip))
print("Initial CS value:", hex(dos_header.e_cs))
print("Overlay number:", dos_header.e_ovno)
print("OEM identifier:", dos_header.e_oemid)
print("OEM information:", dos_header.e_oeminfo)
print("Address of NE header:", hex(dos_header.e_lfanew))


print("Signature:        0x{:X}".format(pe.DOS_HEADER.e_magic))
print("Machine:          0x{:X}".format(pe.FILE_HEADER.Machine))
print("Number of sections:    {}".format(pe.FILE_HEADER.NumberOfSections))
print("Time date stamp:  0x{:X}".format(pe.FILE_HEADER.TimeDateStamp))
print("Pointer to Symbol Table: 0x{:X}".format(pe.FILE_HEADER.PointerToSymbolTable))
print("Number of symbols:    {}".format(pe.FILE_HEADER.NumberOfSymbols))
print("Size of Optional Header:    {}".format(pe.FILE_HEADER.SizeOfOptionalHeader))
print("Characteristics:  0x{:X}".format(pe.FILE_HEADER.Characteristics))

# Print section headers
print("\nSections:")
print("Name\t\tVirtual Address\tVirtual Size\tRaw Size\tCharacteristics")
for section in pe.sections:
    print("{}\t{:08x}\t{:08x}\t{:08x}\t{}".format(section.Name.decode().rstrip('\x00'), section.VirtualAddress, section.Misc_VirtualSize, section.SizeOfRawData, hex(section.Characteristics)))


import pefile
from collections import Counter
import math

pe = pefile.PE('1.14.0-x64.exe')

print("Sections:")
print("Name\t\tVirtual Address\tVirtual Size\tRaw Size\tCharacteristics\tEntropy")
for section in pe.sections:
    section_data = section.get_data()
    entropy = sum(-p * math.log2(p) for p in Counter(section_data).values() if p != 0)
    print("{}\t{:08x}\t{:08x}\t{:08x}\t{}\t\t{:.4f}".format(
        section.Name.decode().rstrip('\x00'),
        section.VirtualAddress,
        section.Misc_VirtualSize,
        section.SizeOfRawData,
        hex(section.Characteristics),
        entropy))

print("Imports:")
for entry in pe.DIRECTORY_ENTRY_IMPORT:
    print(entry.dll.decode())

# Get the imports used by the file
imports = [entry.dll.decode('utf-8') for entry in pe.DIRECTORY_ENTRY_IMPORT]

# Define lists of known process monitoring and malicious behavior imports
monitoring_imports = ['CreateProcess', 'CreateRemoteThread', 'CreateThread', 'OpenProcess', 'OpenThread', 'Process32First', 'Process32Next', 'ReadProcessMemory', 'WriteProcessMemory']
malicious_imports = ['DeleteFile', 'MoveFile', 'CopyFile', 'InternetOpen', 'InternetConnect', 'HttpOpenRequest', 'GetAsyncKeyState', 'GetForegroundWindow', 'GetWindowText', 'ShowWindow']

# Count the total number of imports, monitored imports, and malicious imports
total_imports = len(imports)
monitored_imports = len(set(imports).intersection(monitoring_imports))
malicious_imports = len(set(imports).intersection(malicious_imports))

# Print the results
print("Total imports: {}".format(total_imports))
print("Monitored imports: {}".format(monitored_imports))
print("Malicious imports: {}".format(malicious_imports))

import os
import pathlib

# set the directory path
file = "1.14.0-x64.exe"

# initialize the counters
exe_count = 0
susp_count = 0
text_count = 0


file_ext = pathlib.Path(file).suffix.lower()
if file_ext == ".exe":
        exe_count += 1
elif file_ext in [".bat", ".cmd", ".ps1"]:
        # add any other suspicious extensions to the list
        susp_count += 1
elif file_ext in [".txt", ".csv", ".xml", ".html"]:
        # add any other text file extensions to the list
        text_count += 1

# print the results
print(f"Executable files: {exe_count}")
print(f"Suspicious files: {susp_count}")
print(f"Text files: {text_count}")

import os
import pathlib

# set the directory path
file = "1.14.0-x64.exe"

# initialize the counters
exe_count = 0
susp_count = 0
text_count = 0


file_ext = pathlib.Path(file).suffix.lower()
if file_ext == ".exe":
        exe_count += 1
elif file_ext in [".bat", ".cmd", ".ps1"]:
        # add any other suspicious extensions to the list
        susp_count += 1
elif file_ext in [".txt", ".csv", ".xml", ".html"]:
        # add any other text file extensions to the list
        text_count += 1

# print the results
print(f"Executable files: {exe_count}")
print(f"Suspicious files: {susp_count}")
print(f"Text files: {text_count}")


import subprocess
from scapy.all import *

def capture_pcap(filename):
    # Start capturing traffic using scapy
    packets = sniff(filter="tcp or udp or icmp", timeout=10)

    # Save captured packets to a pcap file
    wrpcap(filename, packets)

    # Print number of captured packets
    print(f"Captured {len(packets)} packets and saved to {filename}")

# Specify the path to the PE file to execute
pe_path = "1.14.0-x64.exe"

# Execute the PE file and capture network traffic during its execution
try:
    subprocess.Popen(pe_path)
    capture_pcap("traffic.pcap")
except Exception as e:
    print(f"An error occurred: {str(e)}")

from scapy.all import *
from scapy.layers.inet import TCP, UDP
from scapy.layers.http import HTTP
from scapy.layers.dns import DNS

# function to count the number of HTTP(S) requests, TCP/UDP connections, and DNS requests
def count_requests(filename):
    # read the pcap file
    packets = rdpcap(filename)
    
    # initialize counters
    http_requests = 0
    tcp_connections = 0
    udp_connections = 0
    dns_requests = 0
    
    # loop through each packet
    for packet in packets:
        # check if the packet is a TCP or UDP packet
        if packet.haslayer(TCP):
            tcp_connections += 1
        elif packet.haslayer(UDP):
            udp_connections += 1
        # check if the packet is an HTTP request
        elif packet.haslayer(HTTP):
            http_requests += 1
        # check if the packet is a DNS request
        elif packet.haslayer(DNS):
            dns_requests += 1
    
    # print the results
    print("HTTP(S) Requests: ", http_requests)
    print("TCP Connections: ", tcp_connections)
    print("UDP Connections: ", udp_connections)
    print("DNS Requests: ", dns_requests)

# example usage
count_requests("traffic.pcap")


import dpkt
import socket

def parse_pcap_file(filename):
    # open the pcap file
    with open(filename, 'rb') as f:
        # create a pcap reader object
        pcap_reader = dpkt.pcap.Reader(f)
        
        # initialize a dictionary to hold the extracted information
        events = []
        
        # loop through each packet in the pcap file
        for timestamp, buf in pcap_reader:
            try:
                # parse the packet using dpkt
                eth = dpkt.ethernet.Ethernet(buf)
                ip = eth.data
                tcp = ip.data
                
                # check if the packet is an HTTP request
                if tcp.dport == 80:
                    # extract the desired information from the packet
                    http = dpkt.http.Request(tcp.data)
                    pid = ""
                    process = ""
                    method = http.method
                    http_code = ""
                    ip_addr = socket.inet_ntoa(ip.src)
                    url = http.uri
                    cn = ""
                    event_type = "HTTP Request"
                    size = len(tcp.data)
                    reputation = ""
                    
                    # add the extracted information to the dictionary
                    events.append({
                        "PID": pid,
                        "Process": process,
                        "Method": method,
                        "HTTP Code": http_code,
                        "IP": ip_addr,
                        "URL": url,
                        "CN": cn,
                        "Type": event_type,
                        "Size": size,
                        "Reputation": reputation
                    })
            except:
                pass
                
        # print the extracted information
        for event in events:
            print(event)

# example usage
parse_pcap_file("traffic.pcap")

import dpkt
import socket

def extract_tcp_info(pcap_file):
    tcp_connections = {}
    with open(pcap_file, 'rb') as f:
        pcap = dpkt.pcap.Reader(f)
        for ts, buf in pcap:
            try:
                eth = dpkt.ethernet.Ethernet(buf)
                ip = eth.data
                tcp = ip.data
                # check if packet is TCP
                if isinstance(tcp, dpkt.tcp.TCP):
                    src_ip = socket.inet_ntoa(ip.src)
                    dst_ip = socket.inet_ntoa(ip.dst)
                    src_port = tcp.sport
                    dst_port = tcp.dport
                    if (src_ip, src_port, dst_ip, dst_port) not in tcp_connections:
                        # new TCP connection
                        tcp_connections[(src_ip, src_port, dst_ip, dst_port)] = {
                            'pid': -1,
                            'process': '',
                            'ip': dst_ip,
                            'domain': socket.getfqdn(dst_ip),
                            'asn': '',
                            'cn': '',
                            'reputation': ''
                        }
            except Exception as e:
                pass # ignore any packets that cannot be parsed
    
    # print the TCP connections information
    for conn, info in tcp_connections.items():
        print(f"PID: {info['pid']}, Process: {info['process']}, IP: {info['ip']}, Domain: {info['domain']}, ASN: {info['asn']}, CN: {info['cn']}, Reputation: {info['reputation']}")

extract_tcp_info("traffic.pcap")


def print_dns_requests(pcap_file):
    # Open the pcap file
    with open(pcap_file, 'rb') as f:
        pcap = dpkt.pcap.Reader(f)
    
        # Loop through each packet
        for ts, buf in pcap:
            # Parse the packet
            eth = dpkt.ethernet.Ethernet(buf)
            ip = eth.data
            
            # Check if the packet is a UDP packet
            if isinstance(ip.data, dpkt.udp.UDP):
                udp = ip.data
                
                # Check if the packet is a DNS packet
                if udp.dport == 53:
                    dns = dpkt.dns.DNS(udp.data)

                    # Loop through each DNS query/response
                    for query in dns.qd:
                        # Print the domain and IP address
                        print(f"Domain: {query.name}")
                        for rr in dns.an:
                            if rr.type == dpkt.dns.DNS_A:
                                print(f"IP: {dpkt.inet_ntoa(rr.rdata)}")

# Example usage
print_dns_requests("traffic.pcap")


# Define a dictionary to map process ID (pid) to process name
pid_to_name = {}

def process_packet(packet):
    # Check if the packet has a raw layer
    if Raw in packet:
        # Extract the payload of the packet
        payload = packet[Raw].load

        # Check if the payload contains a process ID (pid)
        if b"pid=" in payload:
            # Extract the process ID (pid) and process name from the payload
            pid = int(payload.split(b"pid=")[1].split(b"&")[0])
            process_name = payload.split(b"name=")[1].split(b"&")[0].decode("utf-8")

            # Add the process name to the dictionary
            pid_to_name[pid] = process_name

    # Check if the packet has a TCP layer
    if TCP in packet:
        # Extract the process ID (pid) from the TCP layer
        pid = packet[TCP].dport

        # Look up the process name in the dictionary
        process_name = pid_to_name.get(pid, "Unknown")

        # Print the process information
        print(f"PID: {pid}, Process: {process_name}")

# Sniff network traffic and process each packet using the process_packet function
sniff(prn=process_packet, offline="traffic.pcap")
